<?php

namespace VulnerabilityChaser\FrontendBundle\Controller;
use VulnerabilityChaser\FrontendBundle\Entity\Agroups;
use VulnerabilityChaser\FrontendBundle\Entity\Cve;
use VulnerabilityChaser\FrontendBundle\Entity\Scans;
use VulnerabilityChaser\FrontendBundle\Entity\Assets;
use VulnerabilityChaser\FrontendBundle\Entity\Idvulnerabilities;
use VulnerabilityChaser\FrontendBundle\Entity\Vulnerabilities;
use VulnerabilityChaser\FrontendBundle\Entity\Status;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;

class ImportController extends Controller {

	/**
	 * Comprueba si existe una vulnerabilidad en la base de datos que no ha sido detectada
	 * por el Nessus. En caso de existir actualiza el status de dicha vulnerabilidad
	 * a cerrada
	 */
	private function updateStatus($reportVulnerabilities) {	
		$em = $this->getDoctrine()->getEntityManager();

		$query = $em->createQuery(
				'SELECT v FROM FrontendBundle:Vulnerabilities v JOIN v.idvulnerabilities vid JOIN v.assets va JOIN va.agroups vag
				WHERE va.ip = :ip AND vag.name = :name'
		);
		$query->setParameter('name', $reportVulnerabilities[0]['group']->getName());
		$query->setParameter('ip', $reportVulnerabilities[0]['ip']);
		
		try { // Se almacena en $vulnerabilities todas las vulnerabilidades de la base de datos 
			  // que comparten grupo e ip. Por cada una de ellas se comprueba si existe en el
			  // reporte de vulnerabilidades de Nessus. En caso de no existir se interpreta
			  // que dicha vulnerabilidad ya no existe y por lo tanto su estado se actualiza
			  // a cerrada.
			$vulnerabilities = $query->getResult();
		} catch (\Doctrine\ORM\NoResultException $e) {
			return null;
		}

		$tgrupo = $reportVulnerabilities[0]['group']->getName();
		$tip = $reportVulnerabilities[0]['ip'];
		
		foreach ($vulnerabilities as $vulnerability) {
			$exist = FALSE;
			foreach ($reportVulnerabilities as $vul) {
				if (($vulnerability->getPort() == $vul['port']) && ($vulnerability->getIdvulnerabilities()->getNessusplugin() == $vul['nessusPlugin'])) {
					$exist = TRUE;
					break;
				}
			}
			if ($exist == FALSE) { // Si no existe la vulnerabilidad en el reporte de Nessus
				                   // se pasa la vulnerabilidad a cerrada
				$vstatus = new Status();
				$vstatus->setDatestart(new \DateTime());
				$vstatus->setVulnerability($vulnerability);
				$vstatus->setStatus($em->getRepository('FrontendBundle:StatusType')->findOneBy(array('status' => 'closed')));
				
				$em->persist($vstatus);
				$em->flush();
			}
		}
		return TRUE;
	}
	
	/**
	 * Comprueba si existe una vulnerabilidad en la base de datos con ip, nessusPlugin, puerto y grupo 
	 * iguales a $ip, $nessusPlugin, $port y $group respectivamente
	 */
	private function existV($ip, $nessusPlugin, $port, $group) {
		$em = $this->getDoctrine()->getEntityManager();
		
		$query = $em->createQuery(
				'SELECT v FROM FrontendBundle:Vulnerabilities v JOIN v.idvulnerabilities vid JOIN v.assets va JOIN va.agroups vag
				WHERE v.port = :port AND vid.nessusplugin = :nessusplugin AND va.ip = :ip AND vag.name = :name'
		);
		$query->setParameter('port', $port);
		$query->setParameter('nessusplugin', $nessusPlugin);
		$query->setParameter('ip', $ip);
		$query->setParameter('name', $group->getName());
		
		try {
			return $query->getSingleResult();
		} catch (\Doctrine\ORM\NoResultException $e) {
			return null;
		}
	}
	
	/**
	 * Comprueba si existe algún asset en la base de datos con ip y grupo iguales
	 * a $ip y $group respectivamente
	 */
	private function existA($ip, $group) {
		$em = $this->getDoctrine()->getEntityManager();

		$query = $em->createQuery(
				'SELECT a FROM FrontendBundle:Assets a JOIN a.agroups ag 
				WHERE a.ip = :ip AND ag.name = :name'
		);
		$query->setParameter('ip', $ip);
		$query->setParameter('name', $group->getName());
		
		try {
			return $query->getSingleResult();
		} catch (\Doctrine\ORM\NoResultException $e) {
			return null;
		}

	}

	/**
	 * Carga un fichero de resultados de Nessus en la base de datos
	 */
	private function load($file, $agroup) {

		if (file_exists($file)) {
			$xml = simplexml_load_file($file);
		} else {
			exit("Failed to open Nessus file.");
		}

		$em = $this->getDoctrine()->getEntityManager();

		$reportVulnerabilities = array();
		
		foreach ($xml->Report->ReportHost as $host) {
			$os = null;
			$systemType = null;
			foreach ($host->HostProperties->tag as $tag) {
				switch ((string) $tag['name']) {
				case 'host-ip':
					$ip = (string) $tag;
					break;
				case 'operating-system':
					$os = (string) $tag;
					break;
				case 'system-type':
					$systemType = (string) $tag;
					break;
				}
			}
			// Comprobación de la existencia del asset en la base de datos
			$asset = $this->existA($ip, $agroup);
			if ($asset == null) {
				$asset = new Assets();
				$asset->setName((string) $host['name']);
				$asset->setAgroups($agroup);
				$asset->setIp($ip);
				$asset->setOs($os);
				$asset->setSystemType($systemType);
				$em->persist($asset);
			}
			
			foreach ($host->ReportItem as $item) {
				// Comprobación de si ya existe dicha vulnerabilidad en la base de datos	
				$IdvTmp = $em
						->getRepository('FrontendBundle:Idvulnerabilities')
						->findOneBy(
								array('nessusplugin' => (int) $item['pluginID']));
				$vID = new Idvulnerabilities();
				if (!$IdvTmp) {
					$Idvulnerability = new Idvulnerabilities();
					$Idvulnerability->setName((string) $item['pluginName']);
					$Idvulnerability->setNessusplugin((int) $item['pluginID']);
					$Idvulnerability->setSolution((string) $item->solution);
					$Idvulnerability
							->setDescription((string) $item->description);
					$em->persist($Idvulnerability);
					$em->flush();
					$vID = $Idvulnerability;
					foreach ($item->cve as $cve) {
						$cveE = new Cve();
						$cveE->setCve((string) $cve);
						$cveE->setIdvulnerabilities($vID);
						$em->persist($cveE);
						$em->flush();
					}

				} else {
					$vID = $IdvTmp;
				}

				// Comprobación de si ya existe dicha ocurrencia de vulnerabilidad en la base de datos
				if ($this->existV($asset->getIp(), (int) $item['pluginID'],(int) $item['port'], $agroup) == null) {
					$Vulnerability = new Vulnerabilities();
					$Vulnerability->setAssets($asset);
					$Vulnerability->setIdvulnerabilities($vID);
					$Vulnerability->setService((string) $item['svc_name']);
					$Vulnerability->setPort((int) $item['port']);
					$Vulnerability->setProtocol((string) $item['protocol']);
					$Vulnerability->setCvssBase((float) $item->cvss_base_score);
					$Vulnerability->setEvidence((string) $item->plugin_output);
					$Vulnerability->setSeverity((int) $item['severity']);
					
					$vstatus = new Status();
					$vstatus->setDatestart(new \DateTime());
					$vstatus->setVulnerability($Vulnerability);
					$vstatus->setStatus($em->getRepository('FrontendBundle:StatusType')->findOneBy(array('status' => 'open')));
				
					
					$em->persist($Vulnerability);
					$em->persist($vstatus);
            		$em->flush();
				}
				
				/*
				 * Se almacena la vulnerabilidad que se encuentra en el informe
				 * de Nessus para comprobar si alguna de las ya existentes en la
				 * base de datos ha desaparecido
				 */
				$reportVulnerabilities[] = array('ip' => $asset->getIp(), 'nessusPlugin' => (int) $item['pluginID'], 'port' => (int) $item['port'], 'group' => $agroup);
			}
		}
		$em->flush();
		$this->updateStatus($reportVulnerabilities);
		unset($reportVulnerabilities);

		return $this->redirect($this->generateUrl('vulnerabilities'));
	}

	/**
	 * Convierte un vector de objetos Agroups en un vector de cadenas de nombres de Agroups
	 */
	private function groupsArray($groups) {
		$groupsA = array();
		Foreach ($groups as $i => $item) {
			$groupsA[$i] = $item->getName();
		}
		return $groupsA;
	}

	public function uploadAction() {
		$em = $this->getDoctrine()->getEntityManager();
		$agroups = $em->getRepository('FrontendBundle:Agroups')->findAll();

		$defaultData = array();
		$form = $this->createFormBuilder($defaultData)->add('file', 'file')
				->add('newGroup', 'text', array('required' => false))
				->add('group', 'choice',
						array('empty_value' => 'Choose an option',
								'choices' => $this->groupsArray($agroups),
								'required' => false,))->getForm();

		if ($this->getRequest()->getMethod() === 'POST') {
			$form->bindRequest($this->getRequest());
			if ($form->isValid()) {
				$data = $form->getData();

				if (empty($data['newGroup'])) {
					$agroup = $agroups[$data['group']];
				} else {
					$agroup = new Agroups();
					$agroup->setName($data['newGroup']);
				}
				$scan = new Scans();
				$scan->setDate(new \DateTime());
				$scan->file = $data['file'];
				$scan->setAgroups($agroup);

				$em->persist($agroup);
				$em->persist($scan);
				$em->flush();

				return $this->load($scan->getAbsolutePath(), $agroup);
			}
		}

		return $this
				->render('FrontendBundle:Import:upload.html.twig',
						array('form' => $form->createView()));
	}

}
