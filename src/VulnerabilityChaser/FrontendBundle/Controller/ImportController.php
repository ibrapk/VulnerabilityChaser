<?php

namespace VulnerabilityChaser\FrontendBundle\Controller;
use VulnerabilityChaser\FrontendBundle\Entity\Agroups;
use VulnerabilityChaser\FrontendBundle\Entity\Cve;
use VulnerabilityChaser\FrontendBundle\Entity\Scans;
use VulnerabilityChaser\FrontendBundle\Entity\Assets;
use VulnerabilityChaser\FrontendBundle\Entity\Idvulnerabilities;
use VulnerabilityChaser\FrontendBundle\Entity\Vulnerabilities;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;

class ImportController extends Controller {

	/**
	 * Comprueba si existe una vulnerabilidad en la base de datos con ip, nessusPlugin, puerto y grupo 
	 * iguales a $ip, $nessusPlugin, $port y $group respectivamente
	 */
	private function existV($ip, $nessusPlugin, $port, $group) {
		$em = $this->getDoctrine()->getEntityManager();
		
		$query = $em->createQuery(
				'SELECT v FROM FrontendBundle:Vulnerabilities v JOIN v.idvulnerabilities vid JOIN v.assets va JOIN va.agroups vag
				WHERE v.port = :port AND vid.nessusplugin = :nessusplugin AND va.ip = :ip AND vag.name = :name'
		);
		$query->setParameter('port', $port);
		$query->setParameter('nessusplugin', $nessusPlugin);
		$query->setParameter('ip', $ip);
		$query->setParameter('name', $group->getName());
		
		try {
			return $query->getSingleResult();
		} catch (\Doctrine\ORM\NoResultException $e) {
			return null;
		}
	}
	
	/**
	 * Comprueba si existe algún asset en la base de datos con ip y grupo iguales
	 * a $ip y $group respectivamente
	 */
	private function existA($ip, $group) {
		$em = $this->getDoctrine()->getEntityManager();

		$query = $em->createQuery(
				'SELECT a FROM FrontendBundle:Assets a JOIN a.agroups ag 
				WHERE a.ip = :ip AND ag.name = :name'
		);
		$query->setParameter('ip', $ip);
		$query->setParameter('name', $group->getName());
		
		try {
			return $query->getSingleResult();
		} catch (\Doctrine\ORM\NoResultException $e) {
			return null;
		}

	}

	/**
	 * Carga un fichero de resultados de Nessus en la base de datos
	 */
	private function load($file, $agroup) {

		if (file_exists($file)) {
			$xml = simplexml_load_file($file);
		} else {
			exit("Failed to open Nessus file.");
		}

		$em = $this->getDoctrine()->getEntityManager();

		foreach ($xml->Report->ReportHost as $host) {

			foreach ($host->HostProperties->tag as $tag) {
				switch ((string) $tag['name']) {
				case 'host-ip':
					$ip = (string) $tag;
					break;
				case 'operating-system':
					$os = (string) $tag;
					break;
				case 'system-type':
					$systemType = (string) $tag;
					break;
				}
			}
			// Comprobación de la existencia del asset en la base de datos
			$asset = $this->existA($ip, $agroup);
			if ($asset == null) { // TODO algo falla aquí que no comprueba correctametne que ya existe
				$asset = new Assets();
				$asset->setName((string) $host['name']);
				$asset->setAgroups($agroup);
				$asset->setIp($ip);
				$asset->setOs($os);
				$asset->setSystemType($systemType);
				$em->persist($asset);
			}
			
			foreach ($host->ReportItem as $item) {
				// Comprobación de si ya existe dicha vulnerabilidad en la base de datos	
				$IdvTmp = $em
						->getRepository('FrontendBundle:Idvulnerabilities')
						->findOneBy(
								array('nessusplugin' => (int) $item['pluginID']));
				$vID = new Idvulnerabilities();
				if (!$IdvTmp) {
					$Idvulnerability = new Idvulnerabilities();
					$Idvulnerability->setName((string) $item->plugin_name);
					$Idvulnerability->setNessusplugin((int) $item['pluginID']);
					$Idvulnerability->setSolution((string) $item->solution);
					$Idvulnerability
							->setDescription((string) $item->description);
					$em->persist($Idvulnerability);
					$em->flush();
					$vID = $Idvulnerability;
					foreach ($item->cve as $cve) {
						$cveE = new Cve();
						$cveE->setCve((string) $cve);
						$cveE->setIdvulnerabilities($vID);
						$em->persist($cveE);
						$em->flush();
					}

				} else {
					$vID = $IdvTmp;
				}

				// Comprobación de si eya existe dicha ocurrencia de vulnerabilidad en la base de datos
				if ($this->existV($asset->getIp(), (int) $item['pluginID'],(int) $item['port'], $agroup) == null) {
					$Vulnerability = new Vulnerabilities();
					$Vulnerability->setAssets($asset);
					$Vulnerability->setIdvulnerabilities($vID);

					$Vulnerability->setService((string) $item['svc_name']);
					$Vulnerability->setPort((int) $item['port']);
					$Vulnerability->setProtocol((string) $item['protocol']);
					$Vulnerability->setCvssBase((float) $item->cvss_base_score);
					$Vulnerability->setEvidence((string) $item->plugin_output);
					$em->persist($Vulnerability);
					$em->flush();
				}

			}
		}
		$em->flush();

		return $this->redirect($this->generateUrl('vulnerabilities'));
	}

	/**
	 * Convierte un vector de objetos Agroups en un vector de cadenas de nombres de Agroups
	 */

	private function groupsArray($groups) {
		$groupsA = array();
		Foreach ($groups as $i => $item) {
			$groupsA[$i] = $item->getName();
		}
		return $groupsA;
	}

	public function uploadAction() {
		//$form = $this->createForm(new UploadType(), $scan);
		$em = $this->getDoctrine()->getEntityManager();
		$agroups = $em->getRepository('FrontendBundle:Agroups')->findAll();

		$defaultData = array();
		$form = $this->createFormBuilder($defaultData)->add('file', 'file')
				->add('newGroup', 'text', array('required' => false))
				->add('group', 'choice',
						array('empty_value' => 'Choose an option',
								'choices' => $this->groupsArray($agroups),
								'required' => false,))->getForm();

		if ($this->getRequest()->getMethod() === 'POST') {
			$form->bindRequest($this->getRequest());
			if ($form->isValid()) {
				$data = $form->getData();

				if (empty($data['newGroup'])) {
					$agroup = $agroups[$data['group']];
				} else {
					$agroup = new Agroups();
					$agroup->setName($data['newGroup']);
				}
				$scan = new Scans();
				$scan->setDate(new \DateTime());
				$scan->file = $data['file'];
				$scan->setAgroups($agroup);

				$em->persist($agroup);
				$em->persist($scan);
				$em->flush();

				return $this->load($scan->getAbsolutePath(), $agroup);
			}
		}

		return $this
				->render('FrontendBundle:Import:upload.html.twig',
						array('form' => $form->createView()));
	}

}
